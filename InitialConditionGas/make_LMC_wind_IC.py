#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Written by Hilay Shah 2023-

import numpy as np
import h5py
from cfpack import print, hdfio, stop, constants
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from matplotlib import cm
import os
from scipy import exp, pi, interpolate, integrate, special
import scipy.optimize as optimize
import argparse
from scipy.optimize import curve_fit
import math
from scipy.interpolate import RectBivariateSpline
from matplotlib import cm
import multiprocessing
from joblib import Parallel, delayed
from pytreegrav import Accel
from cooling_rate import calculate_internal_energy
from scipy.interpolate import CubicSpline
from multiprocessing import Pool
from scipy.interpolate import RegularGridInterpolator
from scipy.integrate import quad

def galic_params(args):
    # This function outputs some parameters for GalIC .param file based on the input arguments
    v_200 = (10*args.total_DM_mass*constants.m_sol*constants.g_n*70*1e5/1e6/constants.pc)**(1/3)  # in cm/s
    print("GALIC: The virial velocity (km/s) is {}".format(v_200/1e5))
    r_200 = v_200/(10*70*1e5/1e6/constants.pc) # in cm
    print("GALIC: The virial radius (kpc) is {}".format(r_200/constants.pc/1e3))
    md = args.total_stellar_mass/args.total_DM_mass
    print("GALIC: The disk mass fraction is {}".format(md))
    h = 1.8*1e3*constants.pc  # in cm
    print("GALIC: The disk scale length (kpc) is {}".format(h/constants.pc/1e3))
    # calculation for lambda and jd taken from https://arxiv.org/pdf/astro-ph/0411108.pdf
    def fc(c):
        return c*(1-1/(1+c)**2-2*np.log(1+c)/(1+c))/(2*(np.log(1+c)-c/(1+c)**2))
    
    def Mdm(R):  # cumulative mass of DM within radius R where R is in cm
        a = r_200/10*np.sqrt(2*(np.log(1+10)-10/(1+10)))  # in cm
        return args.total_DM_mass*constants.m_sol*(R**2/(R+a)**2)
    
    def Vc(R, h):
        y = R/2/h
        return np.sqrt(constants.g_n/R*Mdm(R)+2*constants.g_n*args.total_stellar_mass*constants.m_sol/h*y**2*(special.i0(y)*special.k0(y)-special.i1(y)*special.k1(y)))
    
    # integrate a function of Vc(R) from 0 to infinity
    def Jd(h):
        func = lambda R: args.total_stellar_mass*constants.m_sol*Vc(R, h)*(R/h)**2*np.exp(-R/h)
        return integrate.quad(func, 0, 2000e3*constants.pc)[0]  # integrate from 0 to 2000 kpc in cm
    
    disk_spin_param = Jd(h)/md/(constants.g_n**(1/2)*(args.total_DM_mass*constants.m_sol)**(3/2)*r_200**(1/2)*(2/fc(10))**(1/2))
    print("GALIC: The disk spin parameter is {}".format(disk_spin_param))
    print("GALIC: The disk scale height ratio is {}".format(args.z_scale_stellar/args.r_scale_stellar))

def rotate_Galic_parameters(args):
    snappath, filename = args.paths[0], args.paths[1]  # path to the snapshot file generated by galic
    # Read the relevant particles for the gpot calculation
    file = h5py.File(snappath+filename,'r+')  # reading the snapshot file generated by galic
    # PartType2 data is the disk particles. Reading the positions of the disk particles
    # PartType1 data is the DM particles. Reading the positions of the DM particles
    pos_disk = file["PartType2"]["Coordinates"][:]
    # Rotate pos_disk by args.theta_LMC about the y-axis
    pos_disk = np.dot(args.R_forward, pos_disk.T).T
    # save the rotated disk particle positions
    args.pos_disk = pos_disk
    # rotate stellar disk velocities
    V_disk = file["PartType2"]["Velocities"][:]
    V_disk = np.dot(args.R_forward, V_disk.T).T
    # save the rotated disk particle velocities
    args.V_disk = V_disk
    # Do the same operations for dark matter
    pos_DM = file["PartType1"]["Coordinates"][:]
    pos_DM = np.dot(args.R_forward, pos_DM.T).T
    args.pos_DM = pos_DM
    V_DM = file["PartType1"]["Velocities"][:]
    V_DM = np.dot(args.R_forward, V_DM.T).T
    args.V_DM = V_DM
    file.close()

def find_halo_scale_height(args):
    def find_diskhalo_interface(args, r_cyl):  # This function takes r_cyl and outputs r_cyl, z_cyl, r_sph at which the disk and halo interface is
        def nH_disk(args, r_cyl, z_cyl):
            r_scale = args.r_scale; z_scale = args.z_scale
            rho0 = args.total_gas_mass/(2*np.pi*r_scale**2*z_scale)
            # Convert density from Msol/kpc^3 to g/cm^3
            rho0 *= constants.m_sol/(constants.pc*1e3)**3
            # convert density to hydrogen number density
            nH0 = rho0/constants.m_p*0.75  # 0.75 is the mass fraction of hydrogen
            return nH0*np.exp(-r_cyl/r_scale)*np.exp(-np.abs(z_cyl)/z_scale)
        
        # find z_cyl at which nH_disk = nH_halo for a given r_cyl
        def func(z_cyl, args, r_cyl):
            return nH_disk(args, r_cyl, z_cyl)-args.nH_halo
        
        z_cyl = optimize.brentq(func, 0, 100, args=(args, r_cyl))
        r_sph = np.sqrt(r_cyl**2+z_cyl**2)
        return np.double([r_cyl, z_cyl, r_sph])
    # find all z_cyl and r_sph at which nH_disk = nH_halo for given r_arr array
    r_arr = np.linspace(0.01, 3, 200)
    r_arr_large = np.linspace(0.01, 50, 100)
    # r_cyl_arr = np.zeros_like(r_arr); z_cyl_arr = np.zeros_like(r_arr); r_sph_arr = np.zeros_like(r_arr)
    # parallelize the following loop
    num_cores = 12; print("Number of cores=", num_cores)
    array = Parallel(n_jobs=num_cores)(delayed(find_diskhalo_interface)(args, r_arr[i]) for i in range(len(r_arr)))
    array = np.double(array); r_sph_arr = array[:, 2]; r_cyl_arr = array[:, 0]; z_cyl_arr = array[:, 1]
    array_large = []
    # run a loop that calls find_disk_halo_interface function for different r_arr_large until an error occurs
    print("making the disk halo interface to accept or reject halo particles...")
    for i in range(len(r_arr_large)):
        # print progress bar at every 10 percent
        if i%int(len(r_arr_large)/10)==0: print("{}% done".format(int(i/len(r_arr_large)*100)))
        try:
            array_large.append(find_diskhalo_interface(args, r_arr_large[i]))
        except:
            break
    array_large = np.double(array_large)
    r_sph_arr_large = array_large[:, 2]; r_cyl_arr_large = array_large[:, 0]; z_cyl_arr_large = array_large[:, 1]
    # interpolate the r_cyl vs z_cyl data
    func = interpolate.interp1d(r_cyl_arr_large, z_cyl_arr_large)
    
    # Find slope of r_sph vs r_cyl at the last point
    m = (r_sph_arr[-1]-r_sph_arr[-2])/(r_cyl_arr[-1]-r_cyl_arr[-2])
    if m>0: 
        print("Minimum halo scale radius found at {} kpc!".format(r_sph_arr.min()))
    else: print("No minimum halo scale radius found!")
    args.r_halo_scale_min = r_sph_arr.min()
    args.r_halo_scale_max = r_sph_arr_large.max(); print("Maximum halo scale radius found at {} kpc!".format(r_sph_arr_large.max()))
    args.disk_halo_interface = func
    print("Disk halo interface function generated and saved in args!")

def generate_particle_positions(args):
    print("Generating gas disk particle positions...")
    sample_size = args.Ngas
    def CDF_density_pol_r(r):
        return 1-np.exp(-r/args.r_scale)*(1+r/args.r_scale)

    def CDF_density_pol_z(z):
        return 1-np.exp(-z/args.z_scale)

    def CDF_density_pol_phi(phi):
        return phi/(2*np.pi)
    
    def inverse_CDF_density_pol_z(p):
        return -args.z_scale*np.log(1-p)
    
    def inverse_CDF_density_pol_phi(p):
        return 2*np.pi*p

    def find_inverse_cdf(func, p):
        return lambda x: func(x)-p

    def find_inverse_value(func, p, guess):
        return optimize.newton(find_inverse_cdf(func, p), guess)
    
    np.random.seed(1)
    uniform_cdf_sampling = np.random.uniform(low=0, high=1, size=sample_size)
    samples = []
    for i in range(sample_size):
        random_number = uniform_cdf_sampling[i]
        # Numerically find the inverse CDF
        initial_guess_r = 1
        inverse_sample_r = find_inverse_value(CDF_density_pol_r, uniform_cdf_sampling[i], initial_guess_r)
        inverse_sample_z = inverse_CDF_density_pol_z(uniform_cdf_sampling[i])
        inverse_sample_phi = inverse_CDF_density_pol_phi(uniform_cdf_sampling[i])
        samples.append(np.double([inverse_sample_r, inverse_sample_phi, inverse_sample_z]))

    samples = np.double(samples); samples[:, 2][1::2] = -samples[:, 2][1::2]; z = samples[:, 2] # make every other element for z negative
    # Making the samples random now...
    np.random.shuffle(samples[:, 0]); np.random.shuffle(samples[:, 1]); np.random.shuffle(samples[:, 2])
    x, y = pol2cart(samples[:, 0], samples[:, 1])  # Converting from polar coordinates to cartesian coordinates
    pos_xyz = np.transpose(np.double([x, y, z]))
    # save the unrotated gas disk in args for future use
    args.unrotated_pos_gasdisk = pos_xyz  # Saving the unrotated gas disk for magnetic fields generation
    # rotate these coordinates by args.theta_LMC about the y-axis by first generating a rotation matrix
    pos_xyz = np.dot(args.R_forward, pos_xyz.T).T
    # save the array in double precision
    # np.save("/scratch/jh2/hs9158/results/data/pt_pos_{}_wind.npy".format(args.Ngas), pos_xyz) 
    args.pos_gas_disk = pos_xyz
    return pos_xyz

def generate_gradient_halo_particle_positions(args):
    print("Generating gas halo particle positions...")
    f = args.disk_halo_interface
    # read data from a csv file
    time_densities = np.loadtxt("/scratch/jh2/hs9158/results/data/SalemDensity.csv", delimiter=",")
    time, densities = time_densities[:, 0], time_densities[:, 1]
    # Fit a cubic spline to the data
    func = CubicSpline(time, densities)
    # find the density between -1000 and 0 Myr
    time_array = np.linspace(-1000, 0, 1000)
    density_array = func(time_array)
    # scale the density_array such that the maximum value corresponds to args.nH_halo
    Salem2nH = args.nH_halo/density_array.max()
    nH_density_array = density_array*Salem2nH
    # convert nH_density_array to a volumetric density array
    density_array = nH_density_array*constants.m_p/0.73
    # Convert time_array to z_array with the velocity of the LMC
    time2z = 1e6*constants.year*np.linalg.norm(args.V_LMC)*1e5/constants.pc/1e3
    z_array = time_array*time2z # in kpc
    # generate fake data that continues beyond the maximum value of z_array with a constant value of nH_density_array.max()
    sim_z_min = z_array[np.argmax(nH_density_array)]-500*time2z-100
    sim_z_cutoff = z_array[np.argmax(nH_density_array)]
    sim_z_array = np.linspace(sim_z_min, sim_z_min+args.Lhaloz, 1000)
    # USe the previous cubic spline until it exists for sim_z_array then just use the maximum value of nH_density_array
    sim_nH_density_array = func(sim_z_array[np.where(sim_z_array<sim_z_cutoff)[0]]/time2z)*Salem2nH
    # make sim_nH_density_array the same size as sim_z_array by appending the maximum value of nH_density_array
    sim_nH_density_array = np.append(sim_nH_density_array, np.ones(len(sim_z_array)-len(sim_nH_density_array))*nH_density_array.max())
    # save these arrays for future use
    args.density_gradient = np.array([sim_z_array, sim_nH_density_array])
    # Fit a cubic spline to sim_nH_density_array and sim_z_array
    func_sim = CubicSpline(sim_z_array, sim_nH_density_array)
    sim_cubic_nH_density_array = func_sim(sim_z_array)
    # Figure out the total number of particles required to fill the entire box by integration
    N_halo = int(constants.m_p/0.73*4e13*constants.pc**3/args.gas_particle_mass/constants.m_sol/0.73*quad(func_sim, sim_z_array.min(), sim_z_array.max())[0])

    def CDF_nH_density_func(z):
        # integrate func_sim(z) from sim_z_array.min() to z
        return quad(func_sim, sim_z_array.min(), z)[0]/quad(func_sim, sim_z_array.min(), sim_z_array.max())[0]
    
    # np.random.seed(1)
    uniform_cdf_sampling = np.random.uniform(low=0, high=1, size=N_halo)
    CDF_z = np.linspace(sim_z_array.min(), sim_z_array.max(), 10000)
    CDF_halo = np.zeros_like(CDF_z)
    for i in range(len(CDF_halo)):
        CDF_halo[i] = CDF_nH_density_func(CDF_z[i])

    CDF_halo_interp = interpolate.interp1d(CDF_halo, CDF_z, kind='linear')
    z_array_pos = CDF_halo_interp(uniform_cdf_sampling)
    # Generate x, and y smaples now from a uniform distribution from -100 to 100
    x = np.random.uniform(low=-100, high=100, size=N_halo); y = np.random.uniform(low=-100, high=100, size=N_halo)
    pos_xyz_halo = np.column_stack((x, y, z_array_pos))
    # translate the halo particles such that the start of the box in z coordinates is at -300 kpc
    tz = args.Lhaloz/4+sim_z_array.min()
    pos_xyz_halo[:, 2] -= tz
    x_int_arr = np.linspace(args.r_halo_scale_min+0.01, args.r_halo_scale_max-0.01, 100)
    z_int_arr = f(x_int_arr)
    # Fit a linear function to x_int_arr and z_int_arr
    m, c = np.polyfit(x_int_arr, z_int_arr, 1)
    # Rotate pos_xyz_halo with args.R_inverse rotation matrix
    pos_xyz_halo_rotated = np.dot(args.R_inverse, pos_xyz_halo.T).T
    r_array, phi = cart2pol(pos_xyz_halo_rotated[:, 0], pos_xyz_halo_rotated[:, 1]); z_array_pos = pos_xyz_halo_rotated[:, 2]
    # find indices in r_array between r_halo_scale_min and r_halo_scale_max
    ind = np.where((r_array>0.01) & (r_array<args.r_halo_scale_max-0.01))[0]
    # find indices in z_array_pos where np.abs(z_array_pos)<z_interface
    ind2 = np.where(np.abs(z_array_pos[ind])<f(r_array[ind]))[0]
    # remove all particles with indices ind[ind2] from pos_xyz_halo
    pos_xyz_halo_rotated = np.delete(pos_xyz_halo_rotated, ind[ind2], axis=0) # removing all particles within the disk halo interface
    pos_xyz_halo = np.dot(args.R_forward, pos_xyz_halo_rotated.T).T
    # make a figure with ax about how the density gradient has been chosen
    # fig, ax = plt.subplots()
    # ax.plot(z_array, nH_density_array, label="Cubic Spline", c='k', linewidth=4, alpha=0.5)
    # ax.scatter(time*time2z, densities*Salem2nH, label="Salem et al. (2015)", c='k')
    # ax.set_xlim((time*time2z).min(), sim_z_array.max())
    # # Make the top x-axis of the plot to be in Myr
    # ax2 = plt.gca().twiny()
    # # ax2.scatter(time, densities*Salem2nH, c='k')
    # ax2.set_xticks(np.linspace(time.min(), sim_z_array.max()/time2z, 9))
    # ax2.set_xticklabels(np.round(np.linspace(time.min(), sim_z_array.max()/time2z, 9), 0))
    # ax2.set_xlabel("Time (Myr)")
    # # draw a vertical line where nH_density_array is maximum and 500 Myr ahead in time before that
    # ax.axvline(x=z_array[np.argmax(nH_density_array)], c='r')
    # ax.axvline(x=z_array[np.argmax(nH_density_array)]-500*time2z, c='r')
    # # Make two more vertical lines at 100 kpc before the first vertical line above and 100 kpc after the second vertical line above
    # ax.axvline(x=z_array[np.argmax(nH_density_array)]+100, c='b')
    # ax.axvline(x=z_array[np.argmax(nH_density_array)]-500*time2z-100, c='b')
    # ax.set_xlabel("z (kpc)"); ax.set_ylabel("Hydrogen Number Density")
    # ax.plot(sim_z_array, sim_nH_density_array, label="Simulated Densities", c='g')
    # # Make two horizontal two-sided arrows between the tw0 vertical lines above with some text
    # ax.annotate("", xy=(z_array[np.argmax(nH_density_array)]+100, nH_density_array.max()/2), xytext=(z_array[np.argmax(nH_density_array)]-500*time2z-100, nH_density_array.max()/2), arrowprops=dict(arrowstyle="<->"), c='b')
    # ax.text(z_array[np.argmax(nH_density_array)]-500*time2z/2, nH_density_array.max()/2, "Total Simulation Box", fontsize=12, c='b')
    # ax.annotate("", xy=(z_array[np.argmax(nH_density_array)], nH_density_array.max()/3), xytext=(z_array[np.argmax(nH_density_array)]-500*time2z, nH_density_array.max()/3), arrowprops=dict(arrowstyle="<->"), c='r')
    # ax.text(z_array[np.argmax(nH_density_array)]-500*time2z/2, nH_density_array.max()/3, "LMC Motion Box", fontsize=12, c='r')
    # ax.plot(sim_z_array, sim_cubic_nH_density_array, label="Simulated Densities (Cubic Spline)", c='b', linestyle='--')


    # ax.legend()
    # plt.show()

    args.pos_gas_halo = pos_xyz_halo
    print("Number of particles in the halo after removing particles outside the intended box is {}".format(len(pos_xyz_halo)))
    args.Nhalo = len(pos_xyz_halo)  # updated args.Nhalo accordingly

    return pos_xyz_halo

def generate_uniform_halo_particle_positions(args):
    func = args.disk_halo_interface
    # Finding the closest perfect cube root to args.Nhalo
    total_halo_mass = args.Lhaloz*(args.Lhaloxy)**2*(1e3*constants.pc)**3*args.nH_halo*constants.m_p/0.73  # density*volume in g
    Nhalo3d = int(total_halo_mass/(args.gas_particle_mass*constants.m_sol))
    args.Nhalo = Nhalo3d
    print("The total desired number of halo particles is {}".format(args.Nhalo))
    np.random.seed(0)
    pos_xyz_halo = np.column_stack((np.random.uniform(low=-args.Lhaloxy/2, high=args.Lhaloxy/2, size=int(Nhalo3d)),
                                   np.random.uniform(low=-args.Lhaloxy/2, high=args.Lhaloxy/2, size=int(Nhalo3d)),
                                   np.random.uniform(low=-args.Lhaloz/4, high=3*args.Lhaloz/4, size=int(Nhalo3d))))
    
    # rotate the halo to be in the same frame as the z-direction momentum vector aligned disk
    pos_xyz_halo_rotated = np.dot(args.R_inverse, pos_xyz_halo.T).T
    # convert pos_xyz_halo to cylindrical coordinates
    r_array, phi = cart2pol(pos_xyz_halo_rotated[:, 0], pos_xyz_halo_rotated[:, 1]); z_array = pos_xyz_halo_rotated[:, 2]
    
    # find indices in r_array between r_halo_scale_min and r_halo_scale_max
    ind = np.where((r_array>0) & (r_array<args.r_halo_scale_max-0.01))[0]
    # find indices in z_array where np.abs(z_array)<z_interface
    ind2 = np.where(np.abs(z_array[ind])<func(r_array[ind]))[0]
    # remove all particles with indices ind[ind2] from pos_xyz_halo
    print("Number of particles in the halo before removing the disk is {}".format(args.Nhalo))
    pos_xyz_halo_rotated = np.delete(pos_xyz_halo_rotated, ind[ind2], axis=0) # removing all particles within the disk halo interface
    print("Number of particles in the halo after removing particles within the disk halo interface is {}".format(len(pos_xyz_halo_rotated)))
    # rotate pos_xyz_halo by args.theta_LMC about the y-axis by first generating a rotation matrix
    pos_xyz_halo = np.dot(args.R_forward, pos_xyz_halo_rotated.T).T
    args.Nhalo = len(pos_xyz_halo)  # updated args.Nhalo accordingly
    # np.save("/scratch/jh2/hs9158/results/data/pt_pos_{}_halo_wind.npy".format(args.Nhalo), pos_xyz_halo)
    args.pos_gas_halo = pos_xyz_halo
    return pos_xyz_halo

def CDF_from_samples(samples):
    samples = np.sort(samples)
    return samples, 1. * np.arange(len(samples)) / (len(samples) - 1)

def spherical2cart(r, phi, theta):
    return [
         r * np.sin(theta) * np.cos(phi),
         r * np.sin(theta) * np.sin(phi),
         r * np.cos(theta)
    ]

def cart2pol(x, y):
    rho = np.sqrt(x**2 + y**2)
    phi = np.arctan2(y, x)
    return rho, phi

def pol2cart(r, phi):
    return r*np.cos(phi), r*np.sin(phi)

def generate_magnetic_fields(args):
    print("Generating magnetic fields...")
    Ngas = args.Ngas; Nhalo = args.Nhalo; ninterp = args.ninterp
    # generating magnetic fields based on the unrotated disk and halo, change this!!!!!!!!!!
    pos_xyz = args.unrotated_pos_gasdisk  # gas disk positions
    if args.scenario != 0: pos_xyz_halo = args.pos_gas_halo  # rotated gas halo positions
    B_array_disk = np.zeros([len(pos_xyz), 3]) # row 1 B_r, row 2 B_phi, row 3 B_z
    # Since B_r and B_z already zero, we only need to assign B_phi in the second row
    r_array, phi = cart2pol(pos_xyz[:, 0], pos_xyz[:, 1]); z_array = pos_xyz[:, 2]
    if args.disk_field_turb or args.disk_field_turb_order:
        
        with open("ISM_Bfield.1", "rb") as file:
            Bfields1 = file.read()

        with open("ISM_Bfield.2", "rb") as file:
            Bfields2 = file.read()

        with open("ISM_Bfield.3", "rb") as file:
            Bfields3 = file.read()

        Bfields1 = (np.frombuffer(Bfields1, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.disk_field_turb_rms
        Bfields2 = (np.frombuffer(Bfields2, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.disk_field_turb_rms
        Bfields3 = (np.frombuffer(Bfields3, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.disk_field_turb_rms

        # interpolate the Bfields for the disk in a 15 kpc box
        x = np.linspace(-args.L_ISM/2, args.L_ISM/2, ninterp)
        y = np.linspace(-args.L_ISM/2, args.L_ISM/2, ninterp)
        z = np.linspace(-args.L_ISM/2, args.L_ISM/2, ninterp)
        X, Y, Z = np.meshgrid(x, y, z)
        Bfieldsx_interp = RegularGridInterpolator((x, y, z), Bfields1)
        Bfieldsy_interp = RegularGridInterpolator((x, y, z), Bfields2)
        Bfieldsz_interp = RegularGridInterpolator((x, y, z), Bfields3)

        # make sure that pos_xyz is within the 15 kpc box for x and y coordinates by making the coordinates periodic
        pos_xyz_periodic = np.copy(pos_xyz)
        pos_xyz_periodic[:, 0] = pos_xyz_periodic[:, 0] + args.L_ISM*np.ceil((-args.L_ISM/2-pos_xyz_periodic[:, 0])/args.L_ISM)
        pos_xyz_periodic[:, 1] = pos_xyz_periodic[:, 1] + args.L_ISM*np.ceil((-args.L_ISM/2-pos_xyz_periodic[:, 1])/args.L_ISM)
        pos_xyz_periodic[:, 2] = pos_xyz_periodic[:, 2] + args.L_ISM*np.ceil((-args.L_ISM/2-pos_xyz_periodic[:, 2])/args.L_ISM)
        # calculate the Bfields at the halo particle positions
        Bxism = Bfieldsx_interp(pos_xyz_periodic)
        Byism = Bfieldsy_interp(pos_xyz_periodic)
        Bzism = Bfieldsz_interp(pos_xyz_periodic)
        if args.disk_field_turb_order:
            B_mag = args.disk_field_order*np.exp(-r_array/args.r_scale)*np.exp(-np.abs(z_array)/args.z_scale)
            B_array_disk[:, 0] = -B_mag*np.sin(phi); B_array_disk[:, 1] = B_mag*np.cos(phi)
            B_array_disk = np.transpose(np.double([Bxism, Byism, Bzism])) + B_array_disk
        else:
            B_array_disk = np.transpose(np.double([Bxism, Byism, Bzism]))


    else:
        B_mag = args.B_0*np.exp(-r_array/args.r_scale)*np.exp(-np.abs(z_array)/args.z_scale)
        # when B_mag is smaller than args.B_0_halo, set B_mag to args.B_0_halo
        if args.scenario != 0: B_mag[np.where(B_mag<=args.B_0_halo)[0]] = args.B_0_halo  # make the interface continuous only if there is an interface
        B_array_disk[:, 0] = -B_mag*np.sin(phi); B_array_disk[:, 1] = B_mag*np.cos(phi)
        if args.field_reversals:
            # add r_array.max() to the field_reversal_radii array last element and zero to the first element
            field_reversal_radii = args.field_reversal_scales*args.r_scale
            field_reversal_radii = np.insert(field_reversal_radii, 0, 0); field_reversal_radii = np.append(field_reversal_radii, r_array.max())
            print("Field reversal radii are {} kpc".format(field_reversal_radii))
            if args.num_field_reversals == len(args.field_reversal_scales):
                # find the indices where the field reversals are to be applied
                # loop over the number of field reversals and find the indices where the field reversal is to be applied based on the field reversal scales
                for i in range(len(field_reversal_radii)-1):
                    if (i+1)%2==0:
                        ind_reverse = np.where((r_array>=field_reversal_radii[i]) & (r_array<=field_reversal_radii[i+1]))[0]
                        B_array_disk[ind_reverse] *= -1
                        print("Field reversal applied between {} and {} kpc".format(field_reversal_radii[i], field_reversal_radii[i+1]))
                    else: print("Field reversal not applied between {} and {} kpc".format(field_reversal_radii[i], field_reversal_radii[i+1]))
            else: print("Number of field reversals and field reversal scales do not match!")

    # Rotate the magnetic field by args.theta_LMC about the y-axis
    B_array_disk = np.dot(args.R_forward, B_array_disk.T).T
    if args.scenario != 0:
        # generating the halo fields now
        with open("CGM_Bfield.1", "rb") as file:
            Bfields1 = file.read()

        with open("CGM_Bfield.2", "rb") as file:
            Bfields2 = file.read()

        with open("CGM_Bfield.3", "rb") as file:
            Bfields3 = file.read()

        Bfields1 = (np.frombuffer(Bfields1, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo
        Bfields2 = (np.frombuffer(Bfields2, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo
        Bfields3 = (np.frombuffer(Bfields3, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo

        # interpolate the Bfields
        x = np.linspace(np.floor(pos_xyz_halo[:,0].min()), np.ceil(pos_xyz_halo[:,0].max()), ninterp)
        y = np.linspace(np.floor(pos_xyz_halo[:,1].min()), np.ceil(pos_xyz_halo[:,1].max()), ninterp)
        z = np.linspace(np.floor(pos_xyz_halo[:,2].min()), np.ceil(pos_xyz_halo[:,2].max()), ninterp)
        X, Y, Z = np.meshgrid(x, y, z)
        Bfieldsx_interp = RegularGridInterpolator((x, y, z), Bfields1)
        Bfieldsy_interp = RegularGridInterpolator((x, y, z), Bfields2)
        Bfieldsz_interp = RegularGridInterpolator((x, y, z), Bfields3)
        # calculate the Bfields at the halo particle positions
        Bx = Bfieldsx_interp(pos_xyz_halo)
        By = Bfieldsy_interp(pos_xyz_halo)
        Bz = Bfieldsz_interp(pos_xyz_halo)
        B_array_halo = np.transpose(np.double([Bx, By, Bz]))
    else: B_array_halo = np.array([[], [], []]).T
    # Wind is initialized with the provided power spectrum of the magnetic fields
    # concatenate the two arrays
    B_array = np.concatenate((B_array_disk, B_array_halo), axis=0)
    np.save("/scratch/jh2/hs9158/results/data/B_array_{}_wind.npy".format(int(Ngas)), B_array)
    return B_array

def convert_to_cylindrical(pos_xyz, quantity_xyz):  # does not work for arrays with multiple rows
    r, phi = cart2pol(pos_xyz[:, 0], pos_xyz[:, 1])
    qr = quantity_xyz[:, 0]*np.cos(phi)+quantity_xyz[:, 1]*np.sin(phi)
    qphi = -quantity_xyz[:, 0]*np.sin(phi)+quantity_xyz[:, 1]*np.cos(phi)
    qz = quantity_xyz[:, 2]
    return np.transpose(np.double([qr, qphi, qz]))

def generate_velocity_fields_tree(args):  # theta defines the tolerance of errors
    print("Generating velocity fields...")
    theta = args.theta
    snappath, filename = args.paths[0], args.paths[1]  # path to the snapshot file generated by galic
    # Read the relevant particles for the gpot calculation
    file = h5py.File(snappath+filename,'r+')  # reading the snapshot file generated by galic
    m_disk = file["PartType2"]["Masses"][:][0]; m_DM = file["PartType1"]["Masses"][:][0]
    file.close()
    # Reading the gas disk particle position and mass data
    m_gas = args.total_gas_mass/args.Ngas  # this should be in msol already rather than 1e10*msol
    # convert masses and positions to CGS units
    m_disk *= 1e10*constants.m_sol; m_DM *= 1e10*constants.m_sol; m_gas *= constants.m_sol
    pos_disk = args.pos_disk*1e3*constants.pc; pos_DM = args.pos_DM*1e3*constants.pc; pos_gas = args.unrotated_pos_gasdisk*1e3*constants.pc
    hsml_kpc = np.double(args.hsml)  # smoothing lengths in kpc
    hsml = np.double(args.hsml)*constants.pc*1e3  # smoothing lengths in cm
    # concatenate all the positions and masses
    pos_total = np.concatenate((pos_gas, pos_DM, pos_disk), axis=0)
    m_total = np.concatenate((np.repeat(m_gas, len(pos_gas)), np.repeat(m_DM, len(pos_DM)), np.repeat(m_disk, len(pos_disk))), axis=0)
    # create a softening array with size of pos_total for all particles with hsml[0] being the smoothing length for gas particles, hsml[1] for DM particles and hsml[2] for disk particles
    sof = np.zeros(len(pos_total))
    sof[:len(pos_gas)] = hsml[0]; sof[len(pos_gas):len(pos_gas)+len(pos_DM)] = hsml[1]; sof[len(pos_gas)+len(pos_DM):] = hsml[2]
    # create an instance of the Accel class
    print("Calculating the acceleration field...")
    acc = Accel(pos_total, m_total, G=constants.g_n, parallel=False, theta=theta, softening=sof)
    print("Acceleration field generated!")
    acc_gas = acc[:len(pos_gas)]
    # convert to cylindrical
    acc_gas_pol = convert_to_cylindrical(pos_gas, acc_gas)
    # calculate the velocity
    v_phi = np.sqrt(np.abs(acc_gas_pol[:, 0])*np.linalg.norm(pos_gas, axis=1))/1e5
    # # converting azimuthal velocity data in cartesian coordinates
    v_phi_cart = np.zeros([len(pos_gas), 3])
    r_array, phi = cart2pol(pos_gas[:, 0], pos_gas[:, 1]); z_array = pos_gas[:, 2]
    # # since the velocity is just in the azimuthal direction
    v_phi_cart[:, 0] = -v_phi*np.sin(phi); v_phi_cart[:, 1] = v_phi*np.cos(phi); v_phi_cart[:, 2] = 0
    # rotate the velocity field by args.theta_LMC about the y-axis
    v_phi_cart = np.dot(args.R_forward, v_phi_cart.T).T
    # Adding a translating z-component to velocity z values
    v_phi_cart[:, 2] = v_phi_cart[:, 2]+np.linalg.norm(args.V_LMC)
    np.save("/scratch/jh2/hs9158/results/data/v_phi_cart_tree_{}_hsml_{}_theta_{}_wind.npy".format(args.Ngas, hsml_kpc[0], theta), v_phi_cart)
    print("Velocity field generated with wind!")
    return v_phi_cart

def generate_SF_threshold(args, plot=False):
    m_gasdisk = args.total_gas_mass/args.Ngas  # this should be in msol already rather than 1e10*msol
    print("Masses of gas particles is "+str(np.round(m_gasdisk, 2)))
    
    # read a text file which was saved using np.savetxt()
    data = np.loadtxt("/scratch/jh2/hs9158/results/data/thermal_equillibrium.txt", delimiter=",")
    # plot both data sets
    if plot:
        plt.figure()
        plt.plot(data[:, 0]/constants.m_p, data[:, 1])
        plt.legend()
        plt.xscale('log')
        plt.yscale('log')
        plt.show()

    rho_eq = data[:, 0]; T_eq = data[:, 1]
    rho_jeans = np.logspace(np.log10(rho_eq.min()), np.log10(rho_eq.max()), 1000)  # in units of g/cm^3
    m_J = m_gasdisk*constants.m_sol  # minimum mass of gas particles in units of g
    m_J_100 = 100*constants.m_sol  # mass of 100 Msol gas particles in units of g
    m_J_1000 = 1000*constants.m_sol  # mass of 1000 Msol gas particles in units of g
    m_J_10 = 10*constants.m_sol  # mass of 10 Msol gas particles in units of g
    T_jeans = (4*np.pi*rho_jeans*m_J**2)**(1/3)*(constants.g_n*1.3*constants.m_p/constants.k_b/5)
    T_jeans_100 = (4*np.pi*rho_jeans*m_J_100**2)**(1/3)*(constants.g_n*1.3*constants.m_p/constants.k_b/5)
    T_jeans_1000 = (4*np.pi*rho_jeans*m_J_1000**2)**(1/3)*(constants.g_n*1.3*constants.m_p/constants.k_b/5)
    T_jeans_10 = (4*np.pi*rho_jeans*m_J_10**2)**(1/3)*(constants.g_n*1.3*constants.m_p/constants.k_b/5)

    # find the intersection of the two curves generated from rho_eq, T_eq and rho_jeans, T_jeans data by interpolate scipy function
    f1 = interpolate.interp1d(rho_eq, T_eq)
    f2 = interpolate.interp1d(rho_jeans, T_jeans)
    # create an array from minimum of rho_eq+delta to maximum of rho_eq-delta with 1000 elements
    rho_array = np.logspace(np.log10(np.min(rho_jeans))+0.01, np.log10(np.max(rho_jeans))-0.01, 1000)
    # find index where difference between f1(rho_array) and f2(rho_array) is minimum
    ind = np.argmin(np.abs(f1(rho_array)-f2(rho_array)))
    rho_SF = rho_array[ind]
    # find closest index in rho_eq to rho_SF
    ind2 = np.argmin(np.abs(rho_eq-rho_SF))
    T_SF = T_eq[ind2]
    SofteningGas = 3/10*2/3*1.3*constants.g_n*constants.m_p/constants.k_b/T_SF*m_J/constants.pc # in pc
    print("SF threshold density is {} particles/cm^3! Make sure the density threshold is changed in LMC.params file!!!!!!!!!".format(rho_SF/1.3/constants.m_p))
    print("Softening length for gas particles is {}/2.8={} pc! Make sure to update it in LMC.params file!!!!!!!!!".format(SofteningGas, SofteningGas/2.8))
    
    # plot the two curves
    if plot:
        plt.figure()
        plt.plot(rho_eq/constants.m_p, T_eq, label='Thermal Equillibrium')
        plt.plot(rho_jeans/constants.m_p, T_jeans, label='Jeans Mass={} Msol'.format(m_J/constants.m_sol))
        plt.plot(rho_jeans/constants.m_p, T_jeans_100, label='Jeans Mass=100 Msol')
        plt.plot(rho_jeans/constants.m_p, T_jeans_1000, label='Jeans Mass=1000 Msol')
        plt.plot(rho_jeans/constants.m_p, T_jeans_10, label='Jeans Mass=10 Msol')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlabel("proton mass density")
        plt.ylabel("Temperature")
        # make a vertical dashed line at rho_SF
        plt.axvline(x=rho_SF/constants.m_p, color='k', linestyle='--', label='SF threshold density')
        plt.legend()
        plt.show()
    return rho_SF

def generate_gradient_internal_energies(args):
    # This is to generate temperatures in hydrostatic equilibrium when there is a density gradient
    z, density = args.density_gradient
    pos_gas_halo = args.pos_gas_halo
    # translate the z values to those in the simulation box
    z -= z.min()-np.round(pos_gas_halo[:,2].min(),0)
    # interpolate the density values
    f = interpolate.interp1d(z, density)
    # generate temperature values based on the density values
    T_gas_halo = density.min()*args.T_gas_halo*2.5/f(pos_gas_halo[:,2])
    stop()
    U_disk, cooling_time_disk = calculate_internal_energy(1e-5, args.T_gas_disk)
    U_halo, cooling_time_halo = calculate_internal_energy(1e-5, T_gas_halo)
    U = np.concatenate((np.repeat(U_disk, args.Ngas), U_halo), axis=0)
    # convert U in erg/g to (km/s)**2 for internal energy to be in the code units
    U *= 1e-10
    args.U = U
    return U

def generate_uniform_internal_energies(args):
    # use calculate_internal_energy function to calculate internal energies
    # make sure the density values imported are small so the gas does not cool a lot when taking a small timestep
    # use 1e4 K as the temperature for gas disk particles, 1e5.5 for gas halo particles
    # use 1e-5 as the density in units of proton mass per cubic cm
    U_disk, cooling_time_disk = calculate_internal_energy(1e-5, args.T_gas_disk)
    if args.scenario == 0: U_halo = np.array([])
    else: U_halo, cooling_time_halo = calculate_internal_energy(1e-5, args.T_gas_halo)
    U = np.concatenate((np.repeat(U_disk, args.Ngas), np.repeat(U_halo, args.Nhalo)), axis=0)
    # convert U in erg/g to (km/s)**2 for internal energy to be in the code units
    U *= 1e-10
    args.U = U
    return U

def translate_to_origin(args):
    # First we need to remove all dark matter particles outside the vicinity of the wind
    # We can do this by removing all particles outside the box defined by the Lhalo values
    
    snappath, filename = args.paths[0], args.paths[1]  # path to the snapshot file generated by galic
    # Read the relevant particles for the gpot calculation
    file = h5py.File(snappath+filename,'r+')  # reading the snapshot file generated by galic
    # Remove all particles outside the box defined by the Lhalo values
    if args.scenario != 0:
        ind = np.where((np.abs(args.pos_DM[:, 0])<args.Lhaloxy/2) & (np.abs(args.pos_DM[:, 1])<args.Lhaloxy/2) &
                        (args.pos_DM[:, 2]<3/4*args.Lhaloz) & (args.pos_DM[:, 2]>-1/4*args.Lhaloz))[0]
        args.ind_DM = ind
    else: args.ind_DM = np.arange(len(args.pos_DM))
    # Now translate all particles to the origin
    # For this we can just translate the wind to the origin and add same values to other particles
    tx = args.Lhaloxy/2; ty = args.Lhaloxy/2; tz = 1/4*args.Lhaloz
    args.pos_DM += np.array([tx, ty, tz]) # DM translation done
    args.pos_disk += np.array([tx, ty, tz])  # stellar disk translation done
    args.pos_gas_disk += np.array([tx, ty, tz])  # gas disk translation done
    if args.scenario != 0: args.pos_gas_halo += np.array([tx, ty, tz])  # gas halo translation done
    np.save("/scratch/jh2/hs9158/results/data/pt_pos_{}_wind.npy".format(args.Ngas), args.pos_gas_disk)
    if args.scenario != 0: np.save("/scratch/jh2/hs9158/results/data/pt_pos_{}_halo_wind.npy".format(args.Nhalo), args.pos_gas_halo)

    # Now add the velocities to the DM and stellar disk particles, so they move with the LMC
    V_LMC = np.linalg.norm(args.V_LMC)
    args.V_disk += np.array([0, 0, V_LMC])
    args.V_DM += np.array([0, 0, V_LMC])
    print("Translation of particles to origin and adding velocities to DM and disk particles done!")

def make_LMC_IC(args):
    '''This function takes an HDF5 input file generated by Galic and adds
    some particle types and physical quantities to generate more realistic
    initial conditions. '''
    Ngas = args.Ngas; Nhalo = args.Nhalo
    # First create a copy of the input HDF5 file and alter it to not affect the original file.
    snappath, filename = args.paths[0], args.paths[1]
    if args.field_reversals: key = "field_reversals_"
    else: key = ""
    if args.B_reduce != 1: key1 = "B_reduce{}_".format(args.B_reduce)
    else: key1 = ""
    if args.disk_field_turb: key2 = "turb{}_".format(args.disk_field_turb_rms/1e-6)
    else: key2 = ""
    if args.disk_field_turb_order: key3 = "turb{}_order{}_".format(args.disk_field_turb_rms/1e-6, args.disk_field_order/1e-6)
    else: key3 = ""

    os.chdir(snappath)
    if os.path.exists("init_wind_scenario_{}_{}{}{}{}".format(args.scenario, key, key1, key2, key3)+filename):
        os.system("rm init_wind_scenario_{}_{}{}{}{}".format(args.scenario, key, key1, key2, key3)+filename)
        print("Old init file removed.")
    os.system("cp "+filename+" init_wind_scenario_{}_{}{}{}{}".format(args.scenario, key, key1, key2, key3)+filename)
    print("New init file created.")

    pos_xyz = np.load("/scratch/jh2/hs9158/results/data/pt_pos_{}_wind.npy".format(int(Ngas))) # Obtaining saved particle positions as per density structure        
    B_xyz = np.load("/scratch/jh2/hs9158/results/data/B_array_{}_wind.npy".format(int(Ngas))) # loading magnetic fields
    v_xyz = np.load("/scratch/jh2/hs9158/results/data/v_phi_cart_tree_{}_hsml_{}_theta_{}_wind.npy".format(args.Ngas, args.hsml[0], args.theta))  # This is just for the gas disk        
    xv_g, yv_g, zv_g = pos_xyz[:, 0], pos_xyz[:,1], pos_xyz[:,2]  # positions defined in kpc
    vx_g=v_xyz[:, 0]; vy_g=v_xyz[:, 1]; vz_g=v_xyz[:, 2]; # initial velocity (in this case radial centrifugal equilibrium in km/s)
    mv_g = np.repeat(args.total_gas_mass/Ngas/1e10, Ngas)  # in 1e10 solar masses (obtained by dividing total gas mass and gas particles)
    # Temperature is defined using the internal energies
    U = args.U
    if args.scenario != 0:  # we need a halo for the other scenarios
        pos_xyz_halo = np.load("/scratch/jh2/hs9158/results/data/pt_pos_{}_halo_wind.npy".format(int(Nhalo))) # Obtaining saved particle positions as per density structure
        v_xyz_halo = np.zeros([len(pos_xyz_halo), 3])  # This is just for the gas halo
        mhalo_g = np.repeat(mv_g[0], Nhalo)  # in 1e10 solar masses (obtained by dividing total gas mass and gas particles)
        id_g=np.arange(1,Ngas+Nhalo+1) # a simple integer list of ids
    else:
        id_g=np.arange(1,Ngas+1)

    file = h5py.File(snappath+"init_wind_scenario_{}_{}{}{}{}".format(args.scenario, key, key1, key2, key3)+filename,'r+')
    if args.scenario != 0:
        npart = np.double([Ngas+Nhalo,len(args.ind_DM),file['PartType2']['Masses'].shape[0],0,0,0]) # We have gas, dark matter, disk particles here
    else:
        npart = np.double([Ngas,file['PartType1']['Masses'].shape[0],file['PartType2']['Masses'].shape[0],0,0,0]) # We have gas, dark matter, disk particles here
        # Assign args.pos_disk to the file["PartType2"]["Coordinates"]

    # Changing the DM PartType1 datasets
    for key in file["PartType1"].keys():
        print("Deleting and replacing "+key+" for PartType1")
        if key == "Coordinates": DM_array = args.pos_DM[args.ind_DM]; print("args.pos_DM used...")
        elif key == "Velocities": DM_array = args.V_DM[args.ind_DM]; print("args.V_DM used...")
        else: DM_array = file["PartType1"][key][:][args.ind_DM]; print("file[PartType1][key] used...")
        del file["PartType1"][key]
        file["PartType1"].create_dataset(key, data=DM_array, dtype='float64')

    # Changing the Disk PartType2 datasets
    del file["PartType2"]["Coordinates"]
    file["PartType2"].create_dataset("Coordinates", data=args.pos_disk, dtype='float64')
    del file["PartType2"]["Velocities"]
    file["PartType2"].create_dataset("Velocities", data=args.V_disk, dtype='float64')
    
    file['Header'].attrs['NumPart_ThisFile'] = npart
    file['Header'].attrs['NumPart_Total'] = npart; # npart set as above
    file["Header"].attrs['MassTable'] = np.zeros(6); # these can be set if all particles will have constant masses for the entire run. however since 
                                        # we set masses explicitly by-particle this should be zero. that is more flexible anyways, as it 
                                        # allows for physics which can change particle masses

    
    # Merging disk and halo gas data
    if args.scenario != 0:
        pos_xyz_gas = np.concatenate((pos_xyz, pos_xyz_halo), axis=0)  # combining both position arrays to create gas particle position array
        m_gas_g = np.concatenate((mv_g, mhalo_g), axis=0)
        v_xyz_gas = np.concatenate((v_xyz, v_xyz_halo), axis=0)
    else:
        pos_xyz_gas = pos_xyz
        m_gas_g = mv_g
        v_xyz_gas = v_xyz

    file.create_group("PartType0")
    file["PartType0"].create_dataset("Coordinates", data=pos_xyz_gas, dtype='float64')
    file["PartType0"].create_dataset("Velocities", data=v_xyz_gas, dtype='float64')
    file["PartType0"].create_dataset("ParticleIDs", data=id_g, dtype='float64')
    file["PartType0"].create_dataset("Masses", data=m_gas_g, dtype='float64')
    file["PartType0"].create_dataset("MagneticField", data=B_xyz, dtype='float64')
    file["PartType0"].create_dataset("InternalEnergy",data=U, dtype='float64')
    file.close()

def make_density_gradient(args):
    time_densities = np.loadtxt("/scratch/jh2/hs9158/results/data/SalemDensity.csv", delimiter=",")
    time, densities = time_densities[:, 0], time_densities[:, 1]
    # Fit a cubic spline to the data
    func = CubicSpline(time, densities)
    # find the density between -1000 and 0 Myr
    time_array = np.linspace(-1000, 0, 1000)
    density_array = func(time_array)
    # scale the density_array such that the maximum value corresponds to args.nH_halo
    Salem2nH = args.nH_halo/density_array.max()
    nH_density_array = density_array*Salem2nH
    # convert nH_density_array to a volumetric density array
    density_array = nH_density_array*constants.m_p/0.73
    # Convert time_array to z_array with the velocity of the LMC
    time2z = 1e6*constants.year*np.linalg.norm(args.V_LMC)*1e5/constants.pc/1e3
    z_array = time_array*time2z # in kpc
    # generate fake data that continues beyond the maximum value of z_array with a constant value of nH_density_array.max()
    sim_z_min = z_array[np.argmax(nH_density_array)]-500*time2z-100
    sim_z_cutoff = z_array[np.argmax(nH_density_array)]
    sim_z_array = np.linspace(sim_z_min, sim_z_min+args.Lhaloz, 1000)
    # USe the previous cubic spline until it exists for sim_z_array then just use the maximum value of nH_density_array
    sim_nH_density_array = func(sim_z_array[np.where(sim_z_array<sim_z_cutoff)[0]]/time2z)*Salem2nH
    # make sim_nH_density_array the same size as sim_z_array by appending the maximum value of nH_density_array
    sim_nH_density_array = np.append(sim_nH_density_array, np.ones(len(sim_z_array)-len(sim_nH_density_array))*nH_density_array.max())
    # save these arrays for future use
    args.density_gradient = np.array([sim_z_array, sim_nH_density_array])
    # Fit a cubic spline to sim_nH_density_array and sim_z_array
    func_sim = CubicSpline(sim_z_array, sim_nH_density_array)
    sim_cubic_nH_density_array = func_sim(sim_z_array)
    # Figure out the total number of particles required to fill the entire box by integration
    N_halo = int(constants.m_p/0.73*4e13*constants.pc**3/args.gas_particle_mass/constants.m_sol/0.73*quad(func_sim, sim_z_array.min(), sim_z_array.max())[0])

    def CDF_nH_density_func(z):
        # integrate func_sim(z) from sim_z_array.min() to z
        return quad(func_sim, sim_z_array.min(), z)[0]/quad(func_sim, sim_z_array.min(), sim_z_array.max())[0]
    
    # np.random.seed(1)
    uniform_cdf_sampling = np.random.uniform(low=0, high=1, size=N_halo)
    CDF_z = np.linspace(sim_z_array.min(), sim_z_array.max(), 10000)
    CDF_halo = np.zeros_like(CDF_z)
    for i in range(len(CDF_halo)):
        CDF_halo[i] = CDF_nH_density_func(CDF_z[i])

    CDF_halo_interp = interpolate.interp1d(CDF_halo, CDF_z, kind='linear')
    z_array_pos = CDF_halo_interp(uniform_cdf_sampling)
    # Generate x, and y smaples now from a uniform distribution from -100 to 100
    x = np.random.uniform(low=-100, high=100, size=N_halo); y = np.random.uniform(low=-100, high=100, size=N_halo)
    pos_xyz_halo = np.column_stack((x, y, z_array_pos))
    # make sure all coordinates are >0 by adding the minimum value of each coordinate to all coordinates
    pos_xyz_halo += np.abs(pos_xyz_halo.min(axis=0))

    # Getting temperature values for the halo particles
    z, density = args.density_gradient
    # translate the z values to those in the simulation box
    z -= z.min()-np.round(pos_xyz_halo[:,2].min(),0)
    # interpolate the density values
    f = interpolate.interp1d(z, density)
    # generate temperature values based on the density values
    T_gas_halo = density.min()*args.T_gas_halo*2.5/f(pos_xyz_halo[:,2])
    U_halo, cooling_time_halo = calculate_internal_energy(1e-5, T_gas_halo)
    # convert U in erg/g to (km/s)**2 for internal energy to be in the code units
    U_halo *= 1e-10

    # Get the magnetic fields for the halo particles
    with open("CGM_Bfield.1", "rb") as file:
        Bfields1 = file.read()

    with open("CGM_Bfield.2", "rb") as file:
        Bfields2 = file.read()

    with open("CGM_Bfield.3", "rb") as file:
        Bfields3 = file.read()
    ninterp = args.ninterp
    Bfields1 = (np.frombuffer(Bfields1, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo
    Bfields2 = (np.frombuffer(Bfields2, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo
    Bfields3 = (np.frombuffer(Bfields3, dtype=np.float64).reshape((ninterp, ninterp, ninterp)))*args.B_0_halo

    # interpolate the Bfields
    x = np.linspace(np.round(pos_xyz_halo[:,0].min(), 0), np.round(pos_xyz_halo[:,0].max(), 0), ninterp)
    y = np.linspace(np.round(pos_xyz_halo[:,1].min(), 0), np.round(pos_xyz_halo[:,1].max(), 0), ninterp)
    z = np.linspace(np.round(pos_xyz_halo[:,2].min(), 0), np.round(pos_xyz_halo[:,2].max(), 0), ninterp)
    X, Y, Z = np.meshgrid(x, y, z)
    Bfieldsx_interp = RegularGridInterpolator((x, y, z), Bfields1)
    Bfieldsy_interp = RegularGridInterpolator((x, y, z), Bfields2)
    Bfieldsz_interp = RegularGridInterpolator((x, y, z), Bfields3)
    # calculate the Bfields at the halo particle positions
    Bx = Bfieldsx_interp(pos_xyz_halo)
    By = Bfieldsy_interp(pos_xyz_halo)
    Bz = Bfieldsz_interp(pos_xyz_halo)
    B_array_halo = np.transpose(np.double([Bx, By, Bz]))

    # Create an HDF5 file with the new halo data
    snappath, filename = args.paths[0], args.paths[1]
    os.chdir(snappath)
    if os.path.exists(snappath+"init_gradient_wind_snap_010.hdf5"):
        os.system("rm "+snappath+"init_gradient_wind_snap_010.hdf5")
        print("Old gradient init file removed.")
    file = h5py.File(snappath+"init_gradient_wind_snap_010.hdf5", 'w')
    file_attr = h5py.File(snappath+"init_wind_scenario_{}_{}{}".format(args.scenario, key)+filename,'r+')
    # copy the header attributes from file_attr to file
    file.create_group("Header")
    for key in file_attr["Header"].attrs.keys():
        file["Header"].attrs[key] = file_attr["Header"].attrs[key]
    file_attr.close()
    npart = np.double([len(pos_xyz_halo),0,0,0,0,0]) # We have gas, dark matter, disk particles here
    file['Header'].attrs['NumPart_ThisFile'] = npart
    file['Header'].attrs['NumPart_Total'] = npart; # npart set as above
    file["Header"].attrs['MassTable'] = np.zeros(6); # these can be set if all particles will have constant masses for the entire run. however since it

    file.create_group("PartType0")
    file["PartType0"].create_dataset("Coordinates", data=pos_xyz_halo, dtype='float64')
    file["PartType0"].create_dataset("Velocities", data=np.zeros([len(pos_xyz_halo), 3]), dtype='float64')
    file["PartType0"].create_dataset("ParticleIDs", data=np.arange(1,len(pos_xyz_halo)+1), dtype='float64')
    file["PartType0"].create_dataset("Masses", data=np.repeat(args.total_gas_mass/args.Ngas/1e10, len(pos_xyz_halo)), dtype='float64')
    file["PartType0"].create_dataset("MagneticField", data=B_array_halo, dtype='float64')
    file["PartType0"].create_dataset("InternalEnergy",data=U_halo, dtype='float64')
    # save the file
    
    file.close()
    
    stop()


if __name__ == "__main__":

    # parse command line arguments
    parser = argparse.ArgumentParser(description='Setting up simulation for LMC with MW wind in GIZMO...')
    parser.add_argument('scenario', type=int, help='The scenario to be used for the simulation')
    args = parser.parse_args()
    # This enables the field reversals functionality
    args.field_reversals = False
    args.num_field_reversals = 1
    args.field_reversal_scales = np.array([1])  # times the scale length of the disk
    # This enables pure turbulent magnetic fields functionality
    args.disk_field_turb = False # whether to add turbulence to the disk field
    args.disk_field_turb_rms = 12e-6  # in Gauss but only used if disk_field_turb is True
    # This enables turbulent plus ordered magnetic fields functionality
    args.disk_field_turb_order = True
    args.disk_field_order = 2e-6  # in Gauss

    # SOME IMPORTANT PARAMETERS DECIDING WHAT SIMULATION WILL BE INITIALIZED WITH INCREASING REALISM
    # The four cases include :- isolated LMC (0), LMC with uniform MW halo (1), LMC with uniform MW wind (2), LMC with non-uniform MW wind (3)
    print_list = ["isolated LMC", "LMC with uniform MW halo", "LMC with uniform MW wind", "LMC with non-uniform MW wind"]
    print("IMPORTANT: The scenario being used is (scenario {}): ".format(args.scenario), print_list[args.scenario])

    # os.system("fieldgen CGM_Bfield 512 13 512 -1.66 1.0")  assuming a 400 kpc box
    # os.system("fieldgen ISM_Bfield 512 15 512 -1.66 1.0") assuming a 15 kpc box, note that it will need to be stitched to cover the entire ISM

    # Comment out all settings except the one you want to use
    # setting 1 (low resolution)
    # args.snappath = '/scratch/jh2/hs9158/gizmo-fork/gizmo2/GalIC/LMC_1e5/'
    # args.Ngas = int(1e5)  # total number of gas particles in the disk in the simulation
    # hsml_scale = 1
    # args.hsml = [0.005*hsml_scale, 0.05*hsml_scale, 0.02*hsml_scale] # smoothing length in kpc for PartType0 (gas), PartType1 (DM), PartType2 (Disk) respectively
    # args.snapnum = 10; args.filename = 'snap_{}.hdf5'.format(str(args.snapnum).zfill(3))

    # setting 2 (medium resolution)
    args.snappath = '/scratch/jh2/hs9158/gizmo-fork/gizmo2/GalIC/LMC_1000sol/'
    args.Ngas = int(22e5)  # total number of gas particles in the disk in the simulation
    hsml_scale = 1
    args.hsml = [0.00084*hsml_scale, 0.05*hsml_scale, 0.02*hsml_scale] # smoothing length in kpc for PartType0 (gas), PartType1 (DM), PartType2 (Disk) respectively
    args.snapnum = 10; args.filename = 'snap_{}.hdf5'.format(str(args.snapnum).zfill(3))

    # setting 2.5 (medium-high resolution)
    # args.snappath = '/scratch/jh2/hs9158/gizmo-fork/gizmo2/GalIC/LMC_250sol/'
    # args.Ngas = int(88e5)  # total number of gas particles in the disk in the simulation
    # hsml_scale = 0.1
    # args.hsml = [0.0021*hsml_scale, 0.05*hsml_scale, 0.02*hsml_scale] # smoothing length in kpc for PartType0 (gas), PartType1 (DM), PartType2 (Disk) respectively
    # args.snapnum = 10; args.filename = 'snap_{}.hdf5'.format(str(args.snapnum).zfill(3))
    

    # # setting 3 (high resolution)
    # args.snappath = '/scratch/jh2/hs9158/gizmo-fork/gizmo2/GalIC/LMC_100sol/'
    # args.Ngas = int(22e6)  # total number of gas particles in the disk in the simulation
    # hsml_scale = 0.1
    # args.hsml = [0.00084*hsml_scale, 0.05*hsml_scale, 0.02*hsml_scale] # smoothing length in kpc for PartType0 (gas), PartType1 (DM), PartType2 (Disk) respectively
    # args.snapnum = 10; args.filename = 'snap_{}.hdf5'.format(str(args.snapnum).zfill(3))

    args.Lhaloz = 400 # in kpc
    args.Lhaloxy = 200 # in kpc
    args.L_ISM = 15  # in kpc
    args.total_DM_mass = 1.775e11  # total DM mass in units of solar masses
    args.total_stellar_mass = 2.5e9  # total stellar mass in units of solar masses
    args.total_gas_mass = 2.2e9 # total gas mass in units of solar masses
    args.T_gas_disk = 1e4  # temperature of gaseous disk in K
    args.T_gas_halo = 2e6  # temperature of ionized gaseous halo in K
    args.nH_halo = 1.1e-4 # wind density in particles/cm^3
    args.B_reduce = 1  # factor by which the peak magnetic field strength is reduced in the disk
    args.B_0 = 2e-6/args.B_reduce  # Peak/rms magnetic field strength in G
    # if args.disk_field_turb or args.disk_field_turb_order is not true, then the peak magnetic field strength in the disk is 4e-6 Gauss
    if args.disk_field_turb_order: print("The turbulent and ordered field strength is {} and {} Gauss respectively".format(args.disk_field_turb_rms, args.disk_field_order))
    elif args.disk_field_turb: print("The turbulent field strength is {} Gauss".format(args.disk_field_turb_rms))
    else: print("The peak ordered magnetic field strength is {} Gauss".format(args.B_0))
    args.B_0_halo = 0.6e-6  # Peak magnetic field strength in G
    args.r_scale_stellar = 1.8  # stellar disk scale length in kpc
    args.z_scale_stellar = 0.3  # stellar disk scale height in kpc
    args.r_scale = 4.8 # gas disk scale length in kpc
    args.z_scale = args.r_scale/10 # gas disk scale height in kpc
    args.gas_particle_mass = args.total_gas_mass/args.Ngas  # mass of gas particles in units of solar masses
    # args.r_halo_scale = 3.3385987  # in kpc. This can be calculated using the find_halo_scale_height function which is commented out above
    args.interp = True
    args.ninterp = 512
    args.theta = 0.4
    args.input_file_path = args.snappath+args.filename
    args.paths = [args.snappath, args.filename]
    # The rotation is decided here for scenario 2 and 3.
    args.n_LMC = np.array([0.43, -0.373, 0.822])
    args.V_LMC = np.array([-314.8, 29.03, -53.951])
    # compute angle between args.n_LMC and args.V_LMC
    args.theta_LMC = 180-np.degrees(np.arccos(np.dot(args.n_LMC, args.V_LMC/np.linalg.norm(args.V_LMC))))
    theta = np.radians(args.theta_LMC)
    args.R_forward = np.array([[np.cos(theta), 0, -np.sin(theta)], [0, 1, 0], [np.sin(theta), 0, np.cos(theta)]])
    args.R_inverse = np.array([[np.cos(-theta), 0, -np.sin(-theta)],[0, 1, 0],[np.sin(-theta), 0, np.cos(-theta)]])  # negative of the making of LMC rotation_matrix
    if args.scenario==0 or args.scenario==1:
        # No translation required in scenario 0 and 1.
        args.V_LMC = np.array([0, 0, 0])
    else: print("The angle between LMC normal and LMC velocity is {} degrees".format(args.theta_LMC))
    
    galic_params(args)
    # make_density_gradient(args)
    # # # # # generate everything
    # if args.scenario==3:
    #     rotate_Galic_parameters(args)
    #     generate_particle_positions(args)
    #     find_halo_scale_height(args)
    #     generate_gradient_halo_particle_positions(args)
    #     generate_magnetic_fields(args)
    #     generate_velocity_fields_tree(args)
    #     generate_gradient_internal_energies(args)
    #     generate_SF_threshold(args)
    #     translate_to_origin(args)
    #     # # # All data should be generated after above functions are run, so the LMC can be saved now...
    #     make_LMC_IC(args)
    if args.scenario==1 or args.scenario==2:
        rotate_Galic_parameters(args)
        generate_particle_positions(args)
        find_halo_scale_height(args)
        generate_uniform_halo_particle_positions(args)
        generate_magnetic_fields(args)
        generate_velocity_fields_tree(args)
        generate_uniform_internal_energies(args)
        generate_SF_threshold(args)
        translate_to_origin(args)
        # # # All data should be generated after above functions are run, so the LMC can be saved now...
        make_LMC_IC(args)
    if args.scenario==0:
        args.Nhalo = 0  # Since halo functions are never called args.Nhalo would remain undefined, so it is defined here
        rotate_Galic_parameters(args)
        generate_particle_positions(args)
        generate_magnetic_fields(args)
        generate_velocity_fields_tree(args)
        generate_uniform_internal_energies(args)
        generate_SF_threshold(args)
        translate_to_origin(args)
        # # # All data should be generated after above functions are run, so the LMC can be saved now...
        make_LMC_IC(args)

    # stop()
    
    # # load the particles to see if everything is working
    file = h5py.File(args.snappath+"init_wind_scenario_{}_snap_010.hdf5".format(args.scenario), 'r')
    # file = h5py.File(args.snappath+"init_wind_scenario_3_turb2_order2_snap_010.hdf5", 'r')
    # # file = h5py.File(args.snappath+"init_gradient_wind_snap_010.hdf5".format(args.scenario), 'r')
    
    pos_disk = file["PartType2"]["Coordinates"][:]
    pos_DM = file["PartType1"]["Coordinates"][:]
    pos_gas = file["PartType0"]["Coordinates"][:]
    # ind = np.random.choice(len(pos_gas), 10000)
    # pos_gas_cen = pos_gas-np.array([100, 100, 100])
    # # rotate the gas particles using the rotation matrix
    # pos_gas_rot = np.dot(args.R_inverse, pos_gas_cen.T).T
    # pos_DM_rot = np.dot(args.R_inverse, pos_DM.T).T
    # pos_disk_rot = np.dot(args.R_inverse, pos_disk.T).T
    # v_gas = file["PartType0"]["Velocities"][:]-np.array([0, 0, np.linalg.norm(args.V_LMC)])
    # B = file["PartType0"]["MagneticField"][:][0:2200000]
    # B_rot = np.dot(args.R_inverse, B.T).T
    # v_gas_rot = np.dot(args.R_inverse, v_gas.T).T
    # v_DM = file["PartType1"]["Velocities"][:]-np.array([0, 0, np.linalg.norm(args.V_LMC)])
    # v_DM_rot = np.dot(args.R_inverse, v_DM.T).T
    # v_disk = file["PartType2"]["Velocities"][:]-np.array([0, 0, np.linalg.norm(args.V_LMC)])
    # v_disk_rot = np.dot(args.R_inverse, v_disk.T).T
    # ind = np.random.choice(len(pos_gas), 1000)
    # stop()
    # plt.figure();plt.quiver(pos_gas_rot[:, 0][ind], pos_gas_rot[:, 1][ind], v_gas_rot[:, 0][ind], v_gas_rot[:, 1][ind], scale=10, scale_units='xy');plt.show()
    # plt.figure();plt.quiver(pos_DM_rot[:, 0], pos_DM_rot[:, 1], v_DM_rot[:, 0], v_DM_rot[:, 1], scale=10, scale_units='xy');plt.show()
    # plt.figure();plt.quiver(pos_disk_rot[:, 0], pos_disk_rot[:, 1], v_disk_rot[:, 0], v_disk_rot[:, 1], scale=10, scale_units='xy');plt.show()

    # stop()
    # particleID = file["PartType0"]["ParticleIDs"][:]
    # ind_gasdisk = np.where(particleID<=args.Ngas)[0]
    # ind_gashalo = np.where(particleID>args.Ngas)[0]
    # pos_xyz = pos_gas[ind_gasdisk]
    # pos_xyz_halo = pos_gas[ind_gashalo]
    # file.close()


    # # B_xyz = np.load("/scratch/jh2/hs9158/results/data/B_xyz.npy")
    # # v_xyz_interp = np.load("/scratch/jh2/hs9158/results/data/v_phi_cart_{}_hsml_{}_interp_{}.npy".format(args.Ngas, args.hsml[0], True))
    # # v_xyz_noninterp = np.load("/scratch/jh2/hs9158/results/data/v_phi_cart_{}_hsml_{}_interp_{}.npy".format(args.Ngas, args.hsml[0], False))
    # # v_xyz_tree = np.load("/scratch/jh2/hs9158/results/data/v_phi_cart_tree_{}_hsml_{}_theta_{}.npy".format(args.Ngas, args.hsml[0], args.theta))

    # stop()
    # # make scatter plot of the positions with different colors
    axis = 2
    plt.figure(figsize=(10,10));
    # choose random 1e6 indices
    ind_gas = np.random.choice(len(pos_gas), 100000)
    ind_DM = np.random.choice(len(pos_DM), 100000)
    ind_disk = np.random.choice(len(pos_disk), 100000)
    plt.scatter(pos_DM[:, 0][ind_DM], pos_DM[:, axis][ind_DM], s=0.1, c='k', alpha=0.05, label='DM')
    plt.scatter(pos_gas[:, 0][ind_gas], pos_gas[:, axis][ind_gas], s=0.1, c='b', alpha=0.1, label='Gas')
    plt.scatter(pos_disk[:, 0][ind_disk], pos_disk[:, axis][ind_disk], s=0.1, c='g', alpha=0.2, label='Old stars')
    
    plt.xlabel("x (kpc)")
    # make the aspect ratio equal
    plt.gca().set_aspect('equal', adjustable='box')
    if axis==1: plt.ylabel("y (kpc)")
    if axis==2: plt.ylabel("z (kpc)")
    plt.xlim([0, 200]); plt.ylim([0, 400]);
    # Place legend outside and make markers opaque
    leg = plt.legend(markerscale=10, bbox_to_anchor=(0.5, 1.05), loc='upper center', ncol=3)
    for lh in leg.legendHandles:
        lh.set_alpha(1.0)
    # plt.annotate(r'$v_{\rm LMC}$', xy=(100, 100), xytext=(100, 150),
    #          arrowprops=dict(facecolor='red', shrink=0.05),
    #          fontsize=12, color='red')
    plt.tight_layout()  # Adjust layout to prevent legend cutoff
    plt.savefig("/scratch/jh2/hs9158/results/paper_plots/wind_IC.png", dpi=100)
    plt.show()
    stop()
